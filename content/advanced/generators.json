{
  "id": "generators",
  "title": "Python Generators",
  "description": "Learn how to create and use generators for efficient data processing and memory optimization.",
  "order": 3,
  "duration": "40 minutes",
  "overview": "Generators are a powerful feature in Python that allow you to create iterators in a simple and elegant way. Unlike regular functions that return a complete result at once, generators yield one item at a time, which makes them memory-efficient for working with large datasets or infinite sequences. In this lesson, you'll learn how generators work, how to create them using both functions and expressions, and explore advanced generator concepts and patterns.",
  "tutorial": "<h3>Introduction to Generators</h3><p>Generators are special functions that return an iterator that yields items one at a time rather than returning all items at once. This makes generators memory-efficient and perfect for working with large datasets or infinite sequences.</p><p>The key difference between a regular function and a generator function is that a generator function uses the <code>yield</code> statement instead of <code>return</code> to provide a result to the caller. When a generator function is called, it returns a generator object without executing the function body. The function body is executed when the <code>next()</code> function is called on the generator object.</p><h3>Creating Generator Functions</h3><p>Here's how to create a simple generator function:</p><pre><code class=\"language-python\"># A simple generator function that yields numbers from 0 to n-1\ndef count_up_to(n):\n    i = 0\n    while i < n:\n        yield i\n        i += 1\n\n# Using the generator\nfor number in count_up_to(5):\n    print(number)\n\n# Output:\n# 0\n# 1\n# 2\n# 3\n# 4</code></pre><p>The <code>yield</code> statement temporarily suspends the function's execution and sends a value back to the caller, but retains enough state to enable the function to resume where it left off. When the function resumes, it continues execution immediately after the last <code>yield</code> run.</p><h3>Generator vs. Regular Functions</h3><p>Let's compare a generator function with a regular function that returns a list:</p><pre><code class=\"language-python\"># Regular function returning a list\ndef get_numbers_list(n):\n    numbers = []\n    i = 0\n    while i < n:\n        numbers.append(i)\n        i += 1\n    return numbers\n\n# Generator function yielding one value at a time\ndef get_numbers_generator(n):\n    i = 0\n    while i < n:\n        yield i\n        i += 1\n\n# Using the regular function\nnumbers_list = get_numbers_list(1000000)  # Creates a list with 1 million numbers\n\n# Using the generator function\nnumbers_gen = get_numbers_generator(1000000)  # Creates a generator object\n\n# The generator doesn't compute all values until they're requested\nfor i, num in enumerate(numbers_gen):\n    if i < 5:  # Only print the first 5 numbers\n        print(num)\n    else:\n        break</code></pre><p>The regular function creates and returns the entire list at once, which can consume a lot of memory for large lists. In contrast, the generator function creates and returns values one at a time, which is much more memory-efficient.</p><h3>Generator Expressions</h3><p>Similar to list comprehensions, Python also supports generator expressions, which are a concise way to create generators:</p><pre><code class=\"language-python\"># List comprehension - creates a full list in memory\nsquares_list = [x*x for x in range(10)]\n\n# Generator expression - creates a generator object\nsquares_gen = (x*x for x in range(10))\n\nprint(squares_list)  # [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\nprint(squares_gen)   # <generator object <genexpr> at 0x...>\n\n# Using the generator\nfor square in squares_gen:\n    print(square)</code></pre><p>Generator expressions are more memory-efficient than list comprehensions because they don't create the entire result in memory at once.</p><h3>Infinite Generators</h3><p>Generators can create infinite sequences without using infinite memory:</p><pre><code class=\"language-python\"># A generator function that yields an infinite sequence\ndef infinite_counter():\n    i = 0\n    while True:\n        yield i\n        i += 1\n\n# Using the infinite generator\ncounter = infinite_counter()\n\n# Getting the next 5 values\nfor _ in range(5):\n    print(next(counter))\n\n# Output:\n# 0\n# 1\n# 2\n# 3\n# 4</code></pre><p>This is one of the key advantages of generators - they can represent infinite sequences without consuming infinite memory.</p><h3>Generators with State</h3><p>Generators can maintain state between yields:</p><pre><code class=\"language-python\"># A generator that maintains a running average\ndef running_average():\n    total = 0\n    count = 0\n    average = 0\n    \n    while True:\n        # Receive a new value from the caller\n        new_value = yield average\n        \n        # Update running average\n        total += new_value\n        count += 1\n        average = total / count\n\n# Using the generator with state\navg_gen = running_average()\n\n# We need to prime the generator by calling next() once\nnext(avg_gen)  # Returns 0\n\n# Now we can send values and get back the running average\nprint(avg_gen.send(10))  # 10.0\nprint(avg_gen.send(20))  # 15.0\nprint(avg_gen.send(30))  # 20.0</code></pre><p>In this example, the generator maintains the running total and count between yields. The <code>send()</code> method allows you to send a value into the generator, which becomes the result of the <code>yield</code> expression.</p><h3>Generator Methods</h3><p>Generators have three additional methods beyond the basic iteration protocol:</p><ul><li><code>send(value)</code>: Sends a value into the generator, which becomes the result of the current <code>yield</code> expression</li><li><code>throw(type, value=None, traceback=None)</code>: Raises an exception at the point where the generator was paused</li><li><code>close()</code>: Raises a <code>GeneratorExit</code> exception inside the generator to terminate it</li></ul><pre><code class=\"language-python\"># A generator demonstrating send, throw, and close\ndef echo_generator():\n    value = None\n    while True:\n        try:\n            value = yield value\n            print(f\"Generator received: {value}\")\n        except ValueError:\n            print(\"Generator caught ValueError\")\n        except GeneratorExit:\n            print(\"Generator is closing\")\n            break\n\n# Create generator and advance to first yield\necho = echo_generator()\nnext(echo)  # Prime the generator\n\n# Send values\nprint(echo.send(\"Hello\"))\nprint(echo.send(42))\n\n# Throw an exception into the generator\necho.throw(ValueError, \"An error occurred\")\n\n# Close the generator\necho.close()</code></pre><h3>Chaining Generators</h3><p>Generators can be composed or chained together to create data processing pipelines:</p><pre><code class=\"language-python\"># Generate numbers\ndef numbers():\n    for i in range(1, 11):\n        yield i\n\n# Filter even numbers\ndef even_filter(nums):\n    for num in nums:\n        if num % 2 == 0:\n            yield num\n\n# Square numbers\ndef square(nums):\n    for num in nums:\n        yield num * num\n\n# Creating a pipeline\npipeline = square(even_filter(numbers()))\n\n# Using the pipeline\nfor num in pipeline:\n    print(num)\n\n# Output:\n# 4    (2²)\n# 16   (4²)\n# 36   (6²)\n# 64   (8²)\n# 100  (10²)</code></pre><p>This pattern allows you to break complex data processing into simpler, reusable components.</p><h3>yield from Expression</h3><p>Python 3.3 introduced the <code>yield from</code> expression, which allows a generator to delegate part of its operations to another generator:</p><pre><code class=\"language-python\"># Without yield from\ndef chain(*iterables):\n    for it in iterables:\n        for item in it:\n            yield item\n\n# With yield from\ndef chain_with_yield_from(*iterables):\n    for it in iterables:\n        yield from it\n\n# Using both functions\nlist1 = [1, 2, 3]\nlist2 = [4, 5, 6]\n\nfor item in chain(list1, list2):\n    print(item, end=' ')\n# 1 2 3 4 5 6\n\nprint('\\n')\n\nfor item in chain_with_yield_from(list1, list2):\n    print(item, end=' ')\n# 1 2 3 4 5 6</code></pre><p><code>yield from</code> is not only more concise but also more efficient because it establishes a direct connection between the inner and outer generators.</p><h3>Generator Applications</h3><p>Generators are useful in many scenarios:</p><ul><li><strong>Memory-efficient data processing</strong>: Process large files or datasets without loading everything into memory</li><li><strong>Infinite sequences</strong>: Represent infinite sequences like mathematical series</li><li><strong>Data pipelines</strong>: Create modular data processing pipelines</li><li><strong>Custom iterators</strong>: Implement custom iteration protocols</li><li><strong>Lazy evaluation</strong>: Compute values only when needed</li></ul><pre><code class=\"language-python\"># Example: Processing a large file line by line\ndef read_large_file(file_path):\n    with open(file_path, 'r') as file:\n        for line in file:\n            yield line.strip()\n\n# Example usage (if we had a large file):\n# for line in read_large_file('large_data.txt'):\n#     if 'important' in line:\n#         print(line)</code></pre><h3>Context Managers with Generators</h3><p>The <code>contextlib.contextmanager</code> decorator allows you to create context managers (for use with <code>with</code> statements) using generators:</p><pre><code class=\"language-python\">from contextlib import contextmanager\n\n@contextmanager\ndef file_manager(filename, mode='r'):\n    try:\n        file = open(filename, mode)\n        yield file\n    finally:\n        file.close()\n\n# Using the context manager\nwith file_manager('example.txt', 'w') as f:\n    f.write('Hello, World!')</code></pre><p>This provides a clean way to ensure that resources are properly cleaned up, even if exceptions occur.</p><h3>Recursive Generators</h3><p>Generators can be recursive, which is useful for traversing hierarchical structures:</p><pre><code class=\"language-python\"># A recursive generator to traverse a directory tree\nimport os\n\ndef files_in_directory(directory):\n    for entry in os.scandir(directory):\n        if entry.is_file():\n            yield entry.path\n        elif entry.is_dir():\n            yield from files_in_directory(entry.path)\n\n# Usage example (if we had a directory structure):\n# for file in files_in_directory('/path/to/directory'):\n#     print(file)</code></pre><h3>Coroutines and Generators</h3><p>Generators can be used as simple coroutines for cooperative multitasking. However, for more advanced asynchronous programming, Python now has native coroutines with <code>async</code>/<code>await</code> syntax that are distinct from generators.</p><pre><code class=\"language-python\"># A simple coroutine using a generator\ndef simple_coroutine():\n    print(\"Coroutine started\")\n    x = yield\n    print(f\"Received: {x}\")\n    y = yield\n    print(f\"Received: {y}\")\n\n# Using the coroutine\ncoro = simple_coroutine()\nnext(coro)  # Start the coroutine\ncoro.send(\"Hello\")  # Send a value\ncoro.send(\"World\")  # Send another value</code></pre><h3>Performance Considerations</h3><p>Generators have some performance characteristics to consider:</p><ul><li>They are more memory-efficient for large datasets</li><li>They can be slower for small datasets due to the overhead of creating and managing the generator object</li><li>They allow you to start processing data immediately, without waiting for an entire collection to be created</li></ul>",
  "examples": [
    {
      "title": "Basic Generator Functions",
      "description": "Creating and using simple generator functions.",
      "code": "# Simple generator function for Fibonacci sequence\ndef fibonacci(limit):\n    \"\"\"Generate Fibonacci numbers up to a limit.\"\"\"\n    a, b = 0, 1\n    while a < limit:\n        yield a\n        a, b = b, a + b\n\n# Using the generator to get Fibonacci numbers up to 100\nprint(\"Fibonacci sequence up to 100:\")\nfor num in fibonacci(100):\n    print(num, end=' ')\nprint(\"\\n\")\n\n# Generator that yields letters from a string\ndef letters_from(text):\n    \"\"\"Generate individual letters from a string.\"\"\"\n    for char in text:\n        if char.isalpha():  # Only yield alphabetic characters\n            yield char.upper()\n\n# Using the generator\ntext = \"Hello, World! 123\"\nprint(f\"Letters from '{text}':\")\nfor letter in letters_from(text):\n    print(letter, end=' ')\nprint(\"\\n\")\n\n# Generator with state - tracks the count of values yielded\ndef counted_yielder(items):\n    \"\"\"Yield items while counting how many have been yielded.\"\"\"\n    count = 0\n    for item in items:\n        count += 1\n        print(f\"Yielding item {count}: {item}\")\n        yield item\n\n# Using the stateful generator\nnumbers = [10, 20, 30, 40, 50]\nprint(\"Counted yielder demonstration:\")\nfor number in counted_yielder(numbers):\n    # Do something with the number\n    processed = number * 2\n    print(f\"Processed value: {processed}\")\nprint(\"\\n\")\n\n# Comparing memory usage: generator vs list comprehension\nimport sys\n\n# Create a large range using both approaches\nlarge_list = [i for i in range(1000000)]\nlarge_gen = (i for i in range(1000000))\n\n# Check memory size\nlist_size = sys.getsizeof(large_list)\ngen_size = sys.getsizeof(large_gen)\n\nprint(\"Memory usage comparison:\")\nprint(f\"List comprehension size: {list_size:,} bytes\")\nprint(f\"Generator expression size: {gen_size:,} bytes\")\nprint(f\"Ratio: List is {list_size / gen_size:.1f}x larger than generator\")",
      "explanation": "This example demonstrates the basics of creating and using generators. We start with a Fibonacci sequence generator, which is a classic example where generators shine as they can create sequences efficiently without storing the entire sequence in memory. The second example shows how to filter characters from a string using a generator, yielding only alphabetic characters. The third example demonstrates how generators maintain state between yields by counting the items as they're processed. Finally, we compare the memory usage between a list comprehension and a generator expression, showing how generators are much more memory-efficient for large datasets."
    },
    {
      "title": "Generator Expressions and Infinite Generators",
      "description": "Using generator expressions and creating infinite sequences.",
      "code": "# Generator expression - similar to list comprehension but creates a generator\nnumbers = [1, 2, 3, 4, 5]\n\n# List comprehension\nsquared_list = [x**2 for x in numbers]\n\n# Generator expression\nsquared_gen = (x**2 for x in numbers)\n\nprint(\"List vs Generator:\")\nprint(f\"List comprehension: {squared_list}\")\nprint(f\"Generator expression: {squared_gen}\")\nprint(f\"Generator values: {list(squared_gen)}\")\n\n# Note: After converting to list, the generator is exhausted\nprint(f\"Trying again: {list(squared_gen)}\")\nprint(\"\\n\")\n\n# Chaining generator expressions\neven_squares = (x**2 for x in range(10) if x % 2 == 0)\nprint(\"Even squares from 0 to 9:\")\nfor square in even_squares:\n    print(square, end=' ')\nprint(\"\\n\")\n\n# Creating an infinite generator\ndef infinite_counter(start=0, step=1):\n    \"\"\"Generate an infinite sequence of numbers.\"\"\"\n    current = start\n    while True:\n        yield current\n        current += step\n\n# Using the infinite generator (carefully!)\nprint(\"Infinite counter with start=5, step=2:\")\ncounter = infinite_counter(5, 2)\nfor _ in range(10):  # Take only the first 10 values\n    print(next(counter), end=' ')\nprint(\"\\n\")\n\n# Infinite prime number generator\ndef is_prime(n):\n    \"\"\"Check if a number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef prime_generator():\n    \"\"\"Generate prime numbers indefinitely.\"\"\"\n    n = 2\n    while True:\n        if is_prime(n):\n            yield n\n        n += 1\n\n# Get the first 10 prime numbers\nprint(\"First 10 prime numbers:\")\nprimes = prime_generator()\nfor _ in range(10):\n    print(next(primes), end=' ')\nprint(\"\\n\")\n\n# Combining infinite generators with 'islice'\nfrom itertools import islice\n\nprint(\"Using islice to limit an infinite generator:\")\n# Get prime numbers from 100 to 110 (the first 10 primes after skipping many)\nprimes = prime_generator()\nfor _ in range(100):  # Skip the first 100 primes\n    next(primes)\n    \nfor prime in islice(primes, 10):  # Take the next 10 primes\n    print(prime, end=' ')",
      "explanation": "This example covers generator expressions, which are a concise way to create generators similar to list comprehensions. It shows the key difference: generator expressions don't compute all values at once, and once a generator is exhausted, it can't be reused. The example also demonstrates infinite generators, which can generate unlimited sequences without consuming unlimited memory. We create an infinite counter and a prime number generator, showing how to use them safely by limiting the number of values we extract. Finally, we use islice from the itertools module to efficiently skip values and take a specific range from an infinite generator."
    },
    {
      "title": "Advanced Generator Techniques",
      "description": "Using send(), throw(), close() and yield from.",
      "code": "# Generator with send() - Two-way communication\ndef counter_with_reset():\n    \"\"\"A generator that counts up but can be reset using send().\"\"\"\n    count = 0\n    while True:\n        # If a value is sent, use it to reset the counter\n        reset_value = yield count\n        if reset_value is not None:\n            count = reset_value\n        else:\n            count += 1\n\n# Using the generator with send()\nprint(\"Generator with send():\")\ncounter = counter_with_reset()\nprint(next(counter))  # Start generator, get 0\nprint(next(counter))  # Get 1\nprint(next(counter))  # Get 2\nprint(counter.send(10))  # Reset to 10 and get 10\nprint(next(counter))  # Get 11\nprint(\"\\n\")\n\n# Generator with throw() - Injecting exceptions\ndef exception_handler():\n    \"\"\"A generator that handles exceptions thrown into it.\"\"\"\n    result = yield \"Ready to handle exceptions\"\n    while True:\n        try:\n            result = yield f\"Got: {result}\"\n        except ValueError as e:\n            result = f\"Handled ValueError: {e}\"\n        except TypeError as e:\n            result = f\"Handled TypeError: {e}\"\n        except Exception as e:\n            result = f\"Handled unexpected exception: {e.__class__.__name__}, {e}\"\n\n# Using the generator with throw()\nprint(\"Generator with throw():\")\nhandler = exception_handler()\nprint(next(handler))  # Start generator\nprint(handler.send(\"normal value\"))  # Normal operation\nprint(handler.throw(ValueError, \"Invalid value\"))  # Throw ValueError\nprint(handler.throw(TypeError, \"Invalid type\"))  # Throw TypeError\nprint(handler.send(\"back to normal\"))  # Resume normal operation\nprint(\"\\n\")\n\n# Generator with close() - Clean resource termination\ndef resource_user():\n    \"\"\"A generator that manages a resource and cleans up when closed.\"\"\"\n    print(\"Resource acquired\")\n    try:\n        yield \"Resource is ready\"\n        yield \"Still using resource\"\n        yield \"Still using resource again\"\n    except GeneratorExit:\n        print(\"Resource released cleanly\")\n    finally:\n        # This will execute whether we get GeneratorExit or another exception\n        print(\"Resource cleanup complete\")\n\n# Using the generator with close()\nprint(\"Generator with close():\")\nresource = resource_user()\nprint(next(resource))  # Acquire and start using resource\nprint(next(resource))  # Continue using resource\nresource.close()  # Explicitly release resource\nprint(\"\\n\")\n\n# yield from - Delegating to sub-generators\ndef subgenerator(n):\n    \"\"\"A generator that yields n values.\"\"\"\n    for i in range(n):\n        yield f\"Subgenerator value {i}\"\n\ndef delegating_generator(n):\n    \"\"\"A generator that delegates to another generator using yield from.\"\"\"\n    print(\"Delegating generator starts\")\n    result = yield from subgenerator(n)\n    print(\"Delegating generator ends\")\n    return result\n\n# Using yield from\nprint(\"Generator with yield from:\")\nfor value in delegating_generator(3):\n    print(value)",
      "explanation": "This example showcases advanced generator techniques. First, we demonstrate the `send()` method, which allows two-way communication between the generator and the caller. Next, we show how `throw()` can inject exceptions into a generator, which can be caught and handled. The third example illustrates `close()`, which is used to properly terminate generators that need to clean up resources. Finally, we demonstrate `yield from`, which allows one generator to delegate part of its operation to another generator. These advanced techniques enable powerful patterns like coroutines and sophisticated error handling in generator-based code."
    },
    {
      "title": "Practical Generator Applications",
      "description": "Real-world applications for generators including data processing pipelines.",
      "code": "# Creating a data processing pipeline with generators\n\n# Step 1: Data source generator\ndef data_source(data):\n    \"\"\"Generate items from a data source.\"\"\"\n    print(\"Data source generator started\")\n    for item in data:\n        print(f\"Sourcing: {item}\")\n        yield item\n\n# Step 2: Data transformer generator\ndef transform_data(items):\n    \"\"\"Transform each item in the stream.\"\"\"\n    print(\"Transformer generator started\")\n    for item in items:\n        transformed = item * 2\n        print(f\"Transforming: {item} -> {transformed}\")\n        yield transformed\n\n# Step 3: Data filter generator\ndef filter_data(items, threshold):\n    \"\"\"Filter items based on a threshold.\"\"\"\n    print(\"Filter generator started\")\n    for item in items:\n        if item > threshold:\n            print(f\"Filtering: {item} passes threshold\")\n            yield item\n        else:\n            print(f\"Filtering: {item} fails threshold\")\n\n# Creating and running the pipeline\ndata = [5, 10, 2, 18, 3, 7]\nprint(\"\\nRunning data processing pipeline:\")\npipeline = filter_data(transform_data(data_source(data)), 15)\n\n# Process the data through the pipeline\nresults = list(pipeline)  # This triggers the entire pipeline to run\nprint(f\"\\nPipeline results: {results}\")\n\n# Implementing a lazy CSV reader using generators\ndef lazy_csv_reader(file_path, delimiter=','):\n    \"\"\"A generator that lazily reads CSV data line by line.\"\"\"\n    try:\n        with open(file_path, 'r') as file:\n            header = next(file).strip().split(delimiter)\n            for line in file:\n                values = line.strip().split(delimiter)\n                # Create a dictionary for each row\n                row = dict(zip(header, values))\n                yield row\n    except StopIteration:\n        # No data in file (just header)\n        return\n    except Exception as e:\n        print(f\"Error reading CSV: {e}\")\n\n# We would use the CSV reader like this if we had a file:\n# for row in lazy_csv_reader('data.csv'):\n#     print(row)\n\n# Using a context manager implemented with a generator\nfrom contextlib import contextmanager\n\n@contextmanager\ndef managed_resource(name):\n    \"\"\"A context manager implemented using a generator.\"\"\"\n    print(f\"Acquiring {name}...\")\n    resource = {\"name\": name, \"value\": 0}  # Simulate acquiring a resource\n    try:\n        yield resource  # Provide the resource to the caller\n    finally:\n        print(f\"Releasing {name}...\")\n        # Simulate resource cleanup\n        resource.clear()\n\n# Using the generator-based context manager\nprint(\"\\nUsing a generator-based context manager:\")\nwith managed_resource(\"Database Connection\") as conn:\n    print(f\"Using {conn['name']}\")\n    conn['value'] = 42\n    print(f\"Modified resource: {conn}\")\n\nprint(\"After with block, resource should be released\")\n\n# Generating combinations with generators (memory efficient)\ndef combinations(items, k):\n    \"\"\"Generate all k-length combinations of items.\"\"\"\n    if k == 0:\n        yield []\n    elif k > 0:\n        for i in range(len(items)):\n            for combo in combinations(items[i+1:], k-1):\n                yield [items[i]] + combo\n\n# Using the combinations generator\nprint(\"\\nGenerating combinations:\")\nitems = ['A', 'B', 'C', 'D']\nprint(\"2-length combinations of\", items)\nfor combo in combinations(items, 2):\n    print(combo)",
      "explanation": "This example demonstrates practical applications of generators. First, we create a data processing pipeline using three generator functions: a data source, a transformer, and a filter. Each generator performs a specific operation on data items, and they're connected together to form a processing pipeline. The computation is lazy—nothing happens until we actually consume the values from the pipeline.\n\nNext, we show how generators can be used to lazily read large CSV files line by line, which is memory-efficient for large datasets. We also demonstrate how the contextlib.contextmanager decorator allows you to create context managers using generators—a clean way to ensure resources are properly acquired and released.\n\nFinally, we implement a function to generate combinations of items, which demonstrates how generators can be used in recursive algorithms to efficiently generate combinatorial results without storing all combinations in memory at once."
    }
  ],
  "practice_code": "# Practice with generators\n\n# 1. First, let's create a simple generator that yields even numbers up to a limit\ndef even_numbers(limit):\n    \"\"\"Generate even numbers up to a limit.\"\"\"\n    num = 0\n    while num <= limit:\n        yield num\n        num += 2\n\n# Test the generator\nprint(\"Even numbers up to 10:\")\nfor num in even_numbers(10):\n    print(num, end=' ')\nprint(\"\\n\")\n\n# 2. Let's create a generator expression to square the numbers\nnumbers = [1, 2, 3, 4, 5]\nsquared = (x**2 for x in numbers)\n\nprint(\"Squared numbers:\")\nfor num in squared:\n    print(num, end=' ')\nprint(\"\\n\")\n\n# 3. Create a generator to simulate a dice roll\nimport random\n\ndef dice_rolls(num_rolls):\n    \"\"\"Simulate dice rolls.\"\"\"\n    for _ in range(num_rolls):\n        yield random.randint(1, 6)\n\nprint(\"10 dice rolls:\")\nrolls = list(dice_rolls(10))\nprint(rolls)\nprint(\"\\n\")\n\n# 4. Create a generator pipeline\ndef pipeline_step1(data):\n    \"\"\"Step 1: Filter out odd numbers.\"\"\"\n    for item in data:\n        if item % 2 == 0:  # Keep only even numbers\n            yield item\n\ndef pipeline_step2(data):\n    \"\"\"Step 2: Multiply each number by 3.\"\"\"\n    for item in data:\n        yield item * 3\n\n# Create and use the pipeline\ndata = range(10)  # 0-9\npipeline = pipeline_step2(pipeline_step1(data))\n\nprint(\"Pipeline result (even numbers multiplied by 3):\")\nfor item in pipeline:\n    print(item, end=' ')\nprint(\"\\n\")\n\n# 5. Using the send method with a generator\ndef echo_generator():\n    \"\"\"A generator that echoes values sent to it.\"\"\"\n    value = None\n    while True:\n        # Receive value from send() and yield it back\n        received = yield value  \n        value = f\"Echo: {received}\"\n\n# Using the echo generator\nprint(\"Echo generator demonstration:\")\necho = echo_generator()\nnext(echo)  # Prime the generator\n\nfor message in [\"Hello\", \"Python\", \"Generators\"]:\n    response = echo.send(message)\n    print(f\"Sent: {message}, Received: {response}\")\n\n# Try creating your own generator below\n# Ideas: word generator, password generator, or other sequence generators\n",
  "quiz": [
    {
      "question": "What is the main difference between a regular function and a generator function in Python?",
      "options": [
        {"text": "Generator functions use the yield statement instead of return", "correct": true},
        {"text": "Generator functions can only return numbers", "correct": false},
        {"text": "Generator functions cannot take arguments", "correct": false},
        {"text": "Generator functions are always faster than regular functions", "correct": false}
      ]
    },
    {
      "question": "What is the primary benefit of using a generator instead of returning a list?",
      "options": [
        {"text": "Generators always process data faster", "correct": false},
        {"text": "Generators can only work with numeric data", "correct": false},
        {"text": "Generators are more memory-efficient for large datasets", "correct": true},
        {"text": "Generators cannot be used in for loops", "correct": false}
      ]
    },
    {
      "question": "How do you create a generator expression in Python?",
      "options": [
        {"text": "(expression for item in iterable)", "correct": true},
        {"text": "[expression for item in iterable]", "correct": false},
        {"text": "{expression for item in iterable}", "correct": false},
        {"text": "<expression for item in iterable>", "correct": false}
      ]
    },
    {
      "question": "What happens when you call next() on a generator that has no more values to yield?",
      "options": [
        {"text": "It returns None", "correct": false},
        {"text": "It raises a StopIteration exception", "correct": true},
        {"text": "It raises a GeneratorExit exception", "correct": false},
        {"text": "It restarts from the beginning", "correct": false}
      ]
    },
    {
      "question": "Which of the following is a valid use case for generators?",
      "options": [
        {"text": "Storing large datasets in memory", "correct": false},
        {"text": "Processing large files without loading them entirely into memory", "correct": true},
        {"text": "Increasing the speed of mathematical operations", "correct": false},
        {"text": "Bypassing Python's type system", "correct": false}
      ]
    }
  ],
  "problems": [
    {
      "id": "fibonacci_generator",
      "title": "Fibonacci Generator",
      "description": "Create a generator function that yields Fibonacci numbers indefinitely. The Fibonacci sequence starts with 0 and 1, and each subsequent number is the sum of the two preceding ones (0, 1, 1, 2, 3, 5, 8, ...).",
      "difficulty": "Easy",
      "starter_code": "def fibonacci_generator():\n    \"\"\"Generate Fibonacci numbers indefinitely.\"\"\"\n    # Your code here\n    pass\n\n# Test your generator\nfib_gen = fibonacci_generator()\n\nprint(\"First 10 Fibonacci numbers:\")\nfor _ in range(10):\n    print(next(fib_gen), end=' ')",
      "tests": [
        {
          "description": "Test first Fibonacci number",
          "code": "fib_gen = fibonacci_generator()\nassert next(fib_gen) == 0, \"First Fibonacci number should be 0\"",
          "expected_output": ""
        },
        {
          "description": "Test second Fibonacci number",
          "code": "fib_gen = fibonacci_generator()\nnext(fib_gen)  # Skip first\nassert next(fib_gen) == 1, \"Second Fibonacci number should be 1\"",
          "expected_output": ""
        },
        {
          "description": "Test first 10 Fibonacci numbers",
          "code": "fib_gen = fibonacci_generator()\nfib_sequence = [next(fib_gen) for _ in range(10)]\nassert fib_sequence == [0, 1, 1, 2, 3, 5, 8, 13, 21, 34], \"First 10 Fibonacci numbers are incorrect\"",
          "expected_output": ""
        }
      ],
      "expected_output": "First 10 Fibonacci numbers:\n0 1 1 2 3 5 8 13 21 34 ",
      "solution": "def fibonacci_generator():\n    \"\"\"Generate Fibonacci numbers indefinitely.\"\"\"\n    a, b = 0, 1\n    while True:\n        yield a\n        a, b = b, a + b\n\n# Test your generator\nfib_gen = fibonacci_generator()\n\nprint(\"First 10 Fibonacci numbers:\")\nfor _ in range(10):\n    print(next(fib_gen), end=' ')"
    },
    {
      "id": "line_reader",
      "title": "File Line Reader",
      "description": "Create a generator function called `read_file_lines` that reads a text file and yields one line at a time. The function should strip any leading/trailing whitespace from each line. If a line contains the string `ERROR`, the generator should also print an error message to the console.",
      "difficulty": "Medium",
      "starter_code": "def read_file_lines(file_path):\n    \"\"\"Read a file and yield each line, while reporting errors.\n    \n    Args:\n        file_path: Path to the file to read\n        \n    Yields:\n        Each line from the file with whitespace stripped\n    \"\"\"\n    # Your code here\n    pass\n\n# For testing, create a small sample file\nwith open('sample.txt', 'w') as f:\n    f.write(\"Line 1: Normal line\\n\")\n    f.write(\"Line 2: Contains ERROR message\\n\")\n    f.write(\"Line 3: Another normal line\\n\")\n    f.write(\"Line 4: Another ERROR occurs here\\n\")\n    f.write(\"Line 5: Final line\\n\")\n\n# Test your generator\nprint(\"Reading file line by line:\")\nfor line in read_file_lines('sample.txt'):\n    print(f\"Processing: {line}\")",
      "tests": [
        {
          "description": "Test normal line processing",
          "code": "# Create test file\nwith open('test1.txt', 'w') as f:\n    f.write(\"Simple test\\n\")\n    f.write(\"  Whitespace test  \\n\")\n\n# Collect lines\nlines = list(read_file_lines('test1.txt'))\nassert lines == [\"Simple test\", \"Whitespace test\"], \"Lines should be stripped of whitespace\"",
          "expected_output": ""
        },
        {
          "description": "Test error detection",
          "code": "import io\nimport sys\n\n# Create test file with ERROR\nwith open('test2.txt', 'w') as f:\n    f.write(\"Normal line\\n\")\n    f.write(\"Line with ERROR present\\n\")\n\n# Capture stdout to check error message\nold_stdout = sys.stdout\nsys.stdout = mystdout = io.StringIO()\n\n# Run generator\nlist(read_file_lines('test2.txt'))\n\n# Restore stdout and check output\nsys.stdout = old_stdout\noutput = mystdout.getvalue()\nassert \"ERROR\" in output, \"Should print error message when 'ERROR' is found\"",
          "expected_output": ""
        },
        {
          "description": "Test file not found handling",
          "code": "try:\n    list(read_file_lines('nonexistent_file.txt'))\n    assert False, \"Should raise FileNotFoundError for missing file\"\nexcept FileNotFoundError:\n    pass",
          "expected_output": ""
        }
      ],
      "expected_output": "Reading file line by line:\nProcessing: Line 1: Normal line\nERROR found in line: Line 2: Contains ERROR message\nProcessing: Line 2: Contains ERROR message\nProcessing: Line 3: Another normal line\nERROR found in line: Line 4: Another ERROR occurs here\nProcessing: Line 4: Another ERROR occurs here\nProcessing: Line 5: Final line",
      "solution": "def read_file_lines(file_path):\n    \"\"\"Read a file and yield each line, while reporting errors.\n    \n    Args:\n        file_path: Path to the file to read\n        \n    Yields:\n        Each line from the file with whitespace stripped\n    \"\"\"\n    try:\n        with open(file_path, 'r') as file:\n            for line in file:\n                # Strip whitespace\n                stripped_line = line.strip()\n                \n                # Check for ERROR\n                if \"ERROR\" in stripped_line:\n                    print(f\"ERROR found in line: {stripped_line}\")\n                \n                # Yield the stripped line\n                yield stripped_line\n    except FileNotFoundError:\n        print(f\"Error: File '{file_path}' not found\")\n        raise\n    except Exception as e:\n        print(f\"Error reading file: {e}\")\n        raise\n\n# For testing, create a small sample file\nwith open('sample.txt', 'w') as f:\n    f.write(\"Line 1: Normal line\\n\")\n    f.write(\"Line 2: Contains ERROR message\\n\")\n    f.write(\"Line 3: Another normal line\\n\")\n    f.write(\"Line 4: Another ERROR occurs here\\n\")\n    f.write(\"Line 5: Final line\\n\")\n\n# Test your generator\nprint(\"Reading file line by line:\")\nfor line in read_file_lines('sample.txt'):\n    print(f\"Processing: {line}\")"
    },
    {
      "id": "data_pipeline",
      "title": "Data Processing Pipeline",
      "description": "Create a data processing pipeline using generators. The pipeline should:\n1. Start with a list of numbers\n2. Filter out odd numbers\n3. Square the remaining (even) numbers\n4. Filter out numbers greater than 100\n5. Compute the running sum (yield the sum after each step)",
      "difficulty": "Hard",
      "starter_code": "def filter_odds(numbers):\n    \"\"\"Filter out odd numbers.\"\"\"\n    # Your code here\n    pass\n\ndef square_numbers(numbers):\n    \"\"\"Square each number.\"\"\"\n    # Your code here\n    pass\n\ndef filter_greater_than(numbers, threshold):\n    \"\"\"Filter out numbers greater than threshold.\"\"\"\n    # Your code here\n    pass\n\ndef running_sum(numbers):\n    \"\"\"Compute the running sum of numbers.\"\"\"\n    # Your code here\n    pass\n\ndef process_data(data):\n    \"\"\"Process data through the entire pipeline.\"\"\"\n    # Create and connect the pipeline steps\n    # Your code here\n    pass\n\n# Test data\ndata = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]\n\n# Run the pipeline\nprint(\"Running data pipeline with:\", data)\nresult = list(process_data(data))\nprint(\"Pipeline result:\", result)",
      "tests": [
        {
          "description": "Test with simple data",
          "code": "data = [1, 2, 3, 4]\nresult = list(process_data(data))\nassert result == [4, 8], \"Pipeline result is incorrect for simple data\"",
          "expected_output": ""
        },
        {
          "description": "Test with numbers that exceed threshold",
          "code": "data = [2, 4, 10, 12]\nresult = list(process_data(data))\n# 2² = 4, 4² = 16, 10² = 100, 12² = 144 (filtered out)\n# Running sum: 4, 4+16=20, 20+100=120\nassert result == [4, 20, 120], \"Pipeline result is incorrect with numbers exceeding threshold\"",
          "expected_output": ""
        },
        {
          "description": "Test with no even numbers",
          "code": "data = [1, 3, 5, 7]\nresult = list(process_data(data))\nassert result == [], \"Pipeline should return empty list when no even numbers\"",
          "expected_output": ""
        },
        {
          "description": "Test each pipeline step individually",
          "code": "# Test filter_odds\nassert list(filter_odds([1, 2, 3, 4])) == [2, 4], \"filter_odds not working\"\n\n# Test square_numbers\nassert list(square_numbers([2, 4])) == [4, 16], \"square_numbers not working\"\n\n# Test filter_greater_than\nassert list(filter_greater_than([4, 16, 144], 100)) == [4, 16], \"filter_greater_than not working\"\n\n# Test running_sum\nassert list(running_sum([4, 16])) == [4, 20], \"running_sum not working\"",
          "expected_output": ""
        }
      ],
      "expected_output": "Running data pipeline with: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]\nPipeline result: [4, 8, 44, 108]",
      "solution": "def filter_odds(numbers):\n    \"\"\"Filter out odd numbers.\"\"\"\n    for num in numbers:\n        if num % 2 == 0:  # Only yield even numbers\n            yield num\n\ndef square_numbers(numbers):\n    \"\"\"Square each number.\"\"\"\n    for num in numbers:\n        yield num ** 2\n\ndef filter_greater_than(numbers, threshold):\n    \"\"\"Filter out numbers greater than threshold.\"\"\"\n    for num in numbers:\n        if num <= threshold:\n            yield num\n\ndef running_sum(numbers):\n    \"\"\"Compute the running sum of numbers.\"\"\"\n    total = 0\n    for num in numbers:\n        total += num\n        yield total\n\ndef process_data(data):\n    \"\"\"Process data through the entire pipeline.\"\"\"\n    # 1. Filter out odd numbers\n    even_numbers = filter_odds(data)\n    \n    # 2. Square the even numbers\n    squared_numbers = square_numbers(even_numbers)\n    \n    # 3. Filter out numbers > 100\n    filtered_numbers = filter_greater_than(squared_numbers, 100)\n    \n    # 4. Compute running sum\n    result = running_sum(filtered_numbers)\n    \n    # Return the final generator in the pipeline\n    return result\n\n# Test data\ndata = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]\n\n# Run the pipeline\nprint(\"Running data pipeline with:\", data)\nresult = list(process_data(data))\nprint(\"Pipeline result:\", result)"
    }
  ],
  "next_lesson": "context_managers"
}
