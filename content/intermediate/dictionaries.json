{
  "id": "dictionaries",
  "title": "Python Dictionaries",
  "description": "Learn to use Python dictionaries effectively for storing and retrieving data.",
  "order": 4,
  "duration": "35 minutes",
  "overview": "Dictionaries are one of Python's most powerful and flexible data structures. They store data as key-value pairs, allowing you to quickly retrieve, modify, and organize information. In this lesson, we'll explore dictionaries in depth, learning about their features, operations, and common use cases. We'll also cover advanced dictionary techniques and performance considerations.",
  "tutorial": "<h3>Introduction to Dictionaries</h3><p>A dictionary in Python is an unordered collection of key-value pairs. Each key in a dictionary maps to a corresponding value. Dictionaries are optimized for retrieving data when you know the key, making them extremely efficient for lookups.</p><h3>Creating Dictionaries</h3><p>There are several ways to create dictionaries in Python:</p><pre><code class=\"language-python\"># Empty dictionary\nempty_dict = {}\nempty_dict2 = dict()\n\n# Dictionary with initial key-value pairs\nperson = {\"name\": \"Alice\", \"age\": 30, \"city\": \"New York\"}\n\n# Using dict() constructor with keyword arguments\nperson2 = dict(name=\"Bob\", age=25, city=\"San Francisco\")\n\n# Creating a dictionary from a list of tuples\nitems = [(\"apple\", 5), (\"banana\", 3), (\"orange\", 2)]\nfruit_count = dict(items)\n\n# Dictionary comprehension\nsquares = {x: x**2 for x in range(1, 6)}\nprint(squares)  # {1: 1, 2: 4, 3: 9, 4: 16, 5: 25}</code></pre><h3>Accessing Dictionary Values</h3><p>You can access values in a dictionary using their keys:</p><pre><code class=\"language-python\"># Basic access with key\nperson = {\"name\": \"Alice\", \"age\": 30, \"city\": \"New York\"}\nprint(person[\"name\"])  # Alice\n\n# Using get() method (safer - returns None or a default value if key doesn't exist)\nprint(person.get(\"age\"))  # 30\nprint(person.get(\"email\"))  # None\nprint(person.get(\"email\", \"Not provided\"))  # Not provided</code></pre><h3>Modifying Dictionaries</h3><p>Dictionaries are mutable, so you can change them after creation:</p><pre><code class=\"language-python\"># Adding or updating key-value pairs\nperson = {\"name\": \"Alice\", \"age\": 30}\n\n# Add a new key-value pair\nperson[\"city\"] = \"New York\"\n\n# Update an existing value\nperson[\"age\"] = 31\n\nprint(person)  # {'name': 'Alice', 'age': 31, 'city': 'New York'}\n\n# Adding multiple key-value pairs using update()\nperson.update({\"email\": \"alice@example.com\", \"phone\": \"555-1234\"})\nprint(person)  # {'name': 'Alice', 'age': 31, 'city': 'New York', 'email': 'alice@example.com', 'phone': '555-1234'}\n\n# Removing key-value pairs\n# Using pop() - removes and returns the value\nemail = person.pop(\"email\")\nprint(email)  # alice@example.com\nprint(person)  # {'name': 'Alice', 'age': 31, 'city': 'New York', 'phone': '555-1234'}\n\n# Using popitem() - removes and returns the last inserted key-value pair\nitem = person.popitem()\nprint(item)  # ('phone', '555-1234')\nprint(person)  # {'name': 'Alice', 'age': 31, 'city': 'New York'}\n\n# Using del statement\ndel person[\"city\"]\nprint(person)  # {'name': 'Alice', 'age': 31}\n\n# Clearing all items\nperson.clear()\nprint(person)  # {}</code></pre><h3>Dictionary Methods</h3><p>Python dictionaries have many useful methods:</p><pre><code class=\"language-python\"># Create a sample dictionary\nperson = {\"name\": \"Alice\", \"age\": 30, \"city\": \"New York\"}\n\n# keys() - returns a view object containing all keys\nkeys = person.keys()\nprint(keys)  # dict_keys(['name', 'age', 'city'])\n\n# values() - returns a view object containing all values\nvalues = person.values()\nprint(values)  # dict_values(['Alice', 30, 'New York'])\n\n# items() - returns a view object containing key-value tuples\nitems = person.items()\nprint(items)  # dict_items([('name', 'Alice'), ('age', 30), ('city', 'New York')])\n\n# Note: These view objects are dynamic and reflect changes to the dictionary\nperson[\"email\"] = \"alice@example.com\"\nprint(keys)  # dict_keys(['name', 'age', 'city', 'email'])\n\n# Converting views to lists\nkey_list = list(person.keys())\nvalue_list = list(person.values())\n\n# Checking if a key exists\nprint(\"name\" in person)  # True\nprint(\"phone\" in person)  # False\n\n# Copying a dictionary\nperson_copy = person.copy()  # Shallow copy\nimport copy\nperson_deep_copy = copy.deepcopy(person)  # Deep copy\n\n# setdefault() - returns the value of a key; if key doesn't exist, inserts key with specified value\nphone = person.setdefault(\"phone\", \"555-1234\")\nprint(phone)  # 555-1234 (key was added)\nname = person.setdefault(\"name\", \"Unknown\")\nprint(name)  # Alice (key already existed)</code></pre><h3>Dictionary Comprehensions</h3><p>Dictionary comprehensions provide a concise way to create dictionaries:</p><pre><code class=\"language-python\"># Basic syntax: {key_expr: value_expr for item in iterable if condition}\n\n# Creating a dictionary of squares\nsquares = {x: x**2 for x in range(1, 6)}\nprint(squares)  # {1: 1, 2: 4, 3: 9, 4: 16, 5: 25}\n\n# With a condition\neven_squares = {x: x**2 for x in range(1, 11) if x % 2 == 0}\nprint(even_squares)  # {2: 4, 4: 16, 6: 36, 8: 64, 10: 100}\n\n# Creating a dictionary from two lists\nnames = [\"Alice\", \"Bob\", \"Charlie\"]\nages = [30, 25, 35]\nname_to_age = {name: age for name, age in zip(names, ages)}\nprint(name_to_age)  # {'Alice': 30, 'Bob': 25, 'Charlie': 35}\n\n# Transforming keys and values of an existing dictionary\noriginal = {\"a\": 1, \"b\": 2, \"c\": 3}\ntransformed = {k.upper(): v * 2 for k, v in original.items()}\nprint(transformed)  # {'A': 2, 'B': 4, 'C': 6}</code></pre><h3>Nested Dictionaries</h3><p>Dictionaries can contain other dictionaries as values, creating nested structures:</p><pre><code class=\"language-python\"># Nested dictionary example\nusers = {\n    \"alice\": {\n        \"name\": \"Alice Smith\",\n        \"email\": \"alice@example.com\",\n        \"age\": 30,\n        \"active\": True\n    },\n    \"bob\": {\n        \"name\": \"Bob Johnson\",\n        \"email\": \"bob@example.com\",\n        \"age\": 25,\n        \"active\": False\n    }\n}\n\n# Accessing nested values\nprint(users[\"alice\"][\"email\"])  # alice@example.com\n\n# Adding a new nested dictionary\nusers[\"charlie\"] = {\n    \"name\": \"Charlie Brown\",\n    \"email\": \"charlie@example.com\",\n    \"age\": 35,\n    \"active\": True\n}\n\n# Modifying a value in a nested dictionary\nusers[\"bob\"][\"active\"] = True\n\n# Iterating through a nested dictionary\nfor username, user_info in users.items():\n    print(f\"User: {username}\")\n    for key, value in user_info.items():\n        print(f\"  {key}: {value}\")</code></pre><h3>Dictionary Performance</h3><p>Dictionaries in Python are implemented as hash tables, which provide efficient lookups, insertions, and deletions:</p><table class=\"table\"><thead><tr><th>Operation</th><th>Average Time Complexity</th><th>Notes</th></tr></thead><tbody><tr><td>Access by key (d[key])</td><td>O(1)</td><td>Constant time lookups</td></tr><tr><td>Insertion (d[key] = value)</td><td>O(1)</td><td>Constant time on average</td></tr><tr><td>Deletion (del d[key])</td><td>O(1)</td><td>Constant time on average</td></tr><tr><td>Membership test (key in d)</td><td>O(1)</td><td>Constant time on average</td></tr><tr><td>Iteration (for key in d)</td><td>O(n)</td><td>Linear in the size of the dictionary</td></tr></tbody></table><p>Some key points to remember:</p><ul><li>Dictionary keys must be hashable (immutable types like strings, numbers, tuples of immutable types)</li><li>Mutable objects like lists and dictionaries cannot be used as keys</li><li>The order of items in a dictionary is preserved in Python 3.7+ (insertion order)</li><li>Dictionaries are memory-intensive compared to lists</li></ul><h3>Specialized Dictionary Types</h3><p>The collections module provides specialized dictionary types:</p><pre><code class=\"language-python\"># defaultdict - provides default values for missing keys\nfrom collections import defaultdict\n\n# defaultdict with int as default factory (starts at 0)\nword_counts = defaultdict(int)\nfor word in [\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"apple\"]:\n    word_counts[word] += 1  # No KeyError for missing keys\n\nprint(dict(word_counts))  # {'apple': 3, 'banana': 2, 'orange': 1}\n\n# defaultdict with list as default factory (starts with empty list)\ngroups = defaultdict(list)\ndata = [(\"A\", 1), (\"B\", 2), (\"A\", 3), (\"C\", 4), (\"B\", 5)]\nfor key, value in data:\n    groups[key].append(value)\n    \nprint(dict(groups))  # {'A': [1, 3], 'B': [2, 5], 'C': [4]}\n\n# OrderedDict - remembers insertion order (less useful in Python 3.7+ where regular dicts preserve order)\nfrom collections import OrderedDict\nod = OrderedDict([('a', 1), ('b', 2), ('c', 3)])\n\n# Counter - count hashable objects\nfrom collections import Counter\ncounter = Counter([\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"apple\"])\nprint(counter)  # Counter({'apple': 3, 'banana': 2, 'orange': 1})\nprint(counter.most_common(2))  # [('apple', 3), ('banana', 2)]</code></pre><h3>Common Dictionary Use Cases</h3><ul><li>Frequency counting (like with Counter)</li><li>Lookup tables and mappings</li><li>Caching results (memoization)</li><li>Representing structured data (like JSON)</li><li>Grouping and indexing data</li><li>Implementing graphs (adjacency lists)</li><li>Implementing sparse data structures</li></ul>",
  "examples": [
    {
      "title": "Data Grouping and Aggregation",
      "description": "Using dictionaries to group and analyze data.",
      "code": "# Sample sales data: [(product, category, price, quantity)]\nsales = [\n    (\"Laptop\", \"Electronics\", 1200, 2),\n    (\"Headphones\", \"Electronics\", 150, 5),\n    (\"Coffee Maker\", \"Kitchen\", 80, 3),\n    (\"Phone\", \"Electronics\", 800, 7),\n    (\"Blender\", \"Kitchen\", 60, 4),\n    (\"Toaster\", \"Kitchen\", 40, 8),\n    (\"Monitor\", \"Electronics\", 300, 3),\n    (\"Microwave\", \"Kitchen\", 150, 2)\n]\n\n# 1. Group sales by category\nsales_by_category = {}\n\nfor product, category, price, quantity in sales:\n    if category not in sales_by_category:\n        sales_by_category[category] = []\n    sales_by_category[category].append((product, price, quantity))\n\nprint(\"Sales grouped by category:\")\nfor category, items in sales_by_category.items():\n    print(f\"\\n{category}:\")\n    for product, price, quantity in items:\n        print(f\"  - {product}: ${price} x {quantity}\")\n\n# 2. Calculate total revenue by category\nrevenue_by_category = {}\n\nfor product, category, price, quantity in sales:\n    revenue = price * quantity\n    if category in revenue_by_category:\n        revenue_by_category[category] += revenue\n    else:\n        revenue_by_category[category] = revenue\n\nprint(\"\\nTotal revenue by category:\")\nfor category, revenue in revenue_by_category.items():\n    print(f\"{category}: ${revenue}\")\n\n# 3. Find the best-selling product in each category\nbest_sellers = {}\n\nfor product, category, price, quantity in sales:\n    if category not in best_sellers or quantity > best_sellers[category][1]:\n        best_sellers[category] = (product, quantity)\n\nprint(\"\\nBest-selling product in each category:\")\nfor category, (product, quantity) in best_sellers.items():\n    print(f\"{category}: {product} ({quantity} units)\")\n\n# 4. Calculate average price by category\ncategory_totals = {}\ncategory_counts = {}\n\nfor product, category, price, quantity in sales:\n    # Add to the total price for this category\n    if category in category_totals:\n        category_totals[category] += price\n        category_counts[category] += 1\n    else:\n        category_totals[category] = price\n        category_counts[category] = 1\n\n# Now calculate the averages\navg_price_by_category = {}\nfor category in category_totals:\n    avg_price_by_category[category] = category_totals[category] / category_counts[category]\n\nprint(\"\\nAverage price by category:\")\nfor category, avg_price in avg_price_by_category.items():\n    print(f\"{category}: ${avg_price:.2f}\")",
      "explanation": "This example demonstrates how dictionaries are excellent for grouping, aggregating, and analyzing data. We start with a list of sales data tuples and perform several analyses: grouping products by category, calculating total revenue by category, finding the best-selling product in each category, and calculating the average price by category. These are common patterns in data analysis. Note how we use dictionaries with simple values (for aggregations), lists as values (for grouping), and tuples as values (for tracking the best seller). This flexibility makes dictionaries powerful for organizing and transforming data."
    },
    {
      "title": "Dictionary as a Cache",
      "description": "Using dictionaries to cache expensive computations.",
      "code": "import time\nimport random\n\n# Simulate an expensive calculation\ndef expensive_computation(n):\n    \"\"\"A function that takes time to compute a result.\"\"\"\n    # Simulate work by sleeping\n    time.sleep(0.1)  \n    return n ** 2\n\n# Regular function without caching\ndef compute_values(numbers):\n    results = {}\n    start_time = time.time()\n    \n    for num in numbers:\n        results[num] = expensive_computation(num)\n    \n    end_time = time.time()\n    return results, end_time - start_time\n\n# Function with caching (memoization)\ndef compute_values_with_cache(numbers):\n    cache = {}  # Our cache dictionary\n    results = {}\n    start_time = time.time()\n    \n    for num in numbers:\n        # Check if the result is already in the cache\n        if num in cache:\n            results[num] = cache[num]\n        else:\n            # Compute the value and store in cache\n            value = expensive_computation(num)\n            cache[num] = value\n            results[num] = value\n    \n    end_time = time.time()\n    return results, end_time - start_time, cache\n\n# Generate test data: list with some repeated values\ntest_data = [random.randint(1, 10) for _ in range(20)]\nprint(f\"Test data: {test_data}\")\n\n# Run without caching\nprint(\"\\nComputing without cache...\")\nresults1, time1 = compute_values(test_data)\nprint(f\"Time taken: {time1:.4f} seconds\")\n\n# Run with caching\nprint(\"\\nComputing with cache...\")\nresults2, time2, cache = compute_values_with_cache(test_data)\nprint(f\"Time taken: {time2:.4f} seconds\")\nprint(f\"Cache contents: {cache}\")\n\n# Verify both functions return the same results\nprint(f\"\\nResults match: {results1 == results2}\")\n\n# Calculate the speedup\nprint(f\"Speedup: {time1/time2:.2f}x faster with caching\")\n\n# Fibonacci example with memoization\ndef fibonacci(n, cache=None):\n    if cache is None:\n        cache = {}\n    \n    # Base cases\n    if n <= 1:\n        return n\n    \n    # Check cache\n    if n in cache:\n        return cache[n]\n    \n    # Compute and store in cache\n    cache[n] = fibonacci(n-1, cache) + fibonacci(n-2, cache)\n    return cache[n]\n\n# Test fibonacci function\nprint(\"\\nFibonacci sequence (first 10 numbers):\")\nfor i in range(10):\n    print(f\"fibonacci({i}) = {fibonacci(i)}\")",
      "explanation": "This example demonstrates the powerful technique of memoization (caching results of expensive function calls) using dictionaries. We compare two approaches: one that recalculates values each time they're needed, and another that stores previously calculated values in a dictionary cache. The time savings are significant when values are reused. The example also shows a classic application of memoization with a recursive Fibonacci function. Without memoization, a naive recursive Fibonacci implementation would recalculate the same values many times, but with our cache dictionary, each value is calculated only once. This technique can transform exponential-time algorithms into linear-time ones in many cases."
    },
    {
      "title": "Nested Dictionaries for Hierarchical Data",
      "description": "Working with complex, nested dictionary structures.",
      "code": "# Nested dictionary representing a company organization\ncompany = {\n    \"name\": \"Tech Innovations Inc.\",\n    \"founded\": 2010,\n    \"departments\": {\n        \"engineering\": {\n            \"director\": \"Alice Johnson\",\n            \"employees\": 40,\n            \"teams\": {\n                \"frontend\": {\n                    \"lead\": \"Bob Smith\",\n                    \"employees\": 12,\n                    \"projects\": [\"Website Redesign\", \"Mobile App\"]\n                },\n                \"backend\": {\n                    \"lead\": \"Charlie Davis\",\n                    \"employees\": 15,\n                    \"projects\": [\"API Services\", \"Database Optimization\"]\n                },\n                \"devops\": {\n                    \"lead\": \"Diana Martinez\",\n                    \"employees\": 8,\n                    \"projects\": [\"CI/CD Pipeline\", \"Cloud Migration\"]\n                }\n            }\n        },\n        \"marketing\": {\n            \"director\": \"Eva Brown\",\n            \"employees\": 20,\n            \"teams\": {\n                \"digital\": {\n                    \"lead\": \"Frank Wilson\",\n                    \"employees\": 8,\n                    \"campaigns\": [\"Social Media\", \"Email\"]\n                },\n                \"content\": {\n                    \"lead\": \"Grace Lee\",\n                    \"employees\": 7,\n                    \"campaigns\": [\"Blog\", \"Video\"]\n                }\n            }\n        },\n        \"finance\": {\n            \"director\": \"Henry Garcia\",\n            \"employees\": 15\n        }\n    }\n}\n\n# 1. Basic access to nested values\nprint(f\"Company: {company['name']}\")\nprint(f\"Engineering Director: {company['departments']['engineering']['director']}\")\nprint(f\"Backend Team Lead: {company['departments']['engineering']['teams']['backend']['lead']}\")\n\n# 2. Safe access with get() for deeply nested values\ndef safe_get(dictionary, *keys, default=None):\n    \"\"\"Safely access nested dictionary values.\"\"\"\n    current = dictionary\n    for key in keys:\n        if isinstance(current, dict) and key in current:\n            current = current[key]\n        else:\n            return default\n    return current\n\n# Using our safe_get function\nfrontend_lead = safe_get(company, 'departments', 'engineering', 'teams', 'frontend', 'lead')\nhr_director = safe_get(company, 'departments', 'hr', 'director', default='Not found')\n\nprint(f\"\\nFrontend Team Lead: {frontend_lead}\")\nprint(f\"HR Director: {hr_director}\")\n\n# 3. Adding, modifying, and removing nested data\n# Add a new department\ncompany['departments']['hr'] = {\n    \"director\": \"Irene Taylor\",\n    \"employees\": 10\n}\n\n# Modify a nested value\ncompany['departments']['engineering']['teams']['backend']['employees'] = 18\n\n# Remove a nested item\ndel company['departments']['marketing']['teams']['content']['campaigns']\n\n# 4. Traversing a nested dictionary\ndef traverse_dict(d, path=\"\"):\n    \"\"\"Recursively print all paths and values in a nested dictionary.\"\"\"\n    for key, value in d.items():\n        current_path = f\"{path}.{key}\" if path else key\n        \n        if isinstance(value, dict):\n            # Recursively traverse nested dictionaries\n            traverse_dict(value, current_path)\n        else:\n            # Print leaf values\n            print(f\"{current_path} = {value}\")\n\nprint(\"\\nTraversing company structure:\")\ntraverse_dict(company)\n\n# 5. Summarizing nested data\ndef count_employees_by_department(company):\n    \"\"\"Count total employees in each department.\"\"\"\n    result = {}\n    for dept_name, dept_info in company['departments'].items():\n        # Get direct employees\n        total = dept_info['employees']\n        \n        # Subtract team employees if teams exist (to avoid double counting)\n        if 'teams' in dept_info:\n            team_employees = sum(team['employees'] for team in dept_info['teams'].values())\n            # Assuming department employee count includes team employees\n            # total = total\n        \n        result[dept_name] = total\n    \n    return result\n\nemployee_counts = count_employees_by_department(company)\nprint(\"\\nEmployee counts by department:\")\nfor dept, count in employee_counts.items():\n    print(f\"{dept}: {count} employees\")",
      "explanation": "This example demonstrates how to work with complex, deeply nested dictionary structures, which are common when representing hierarchical data like organization charts, file systems, or JSON data from APIs. We show basic nested access, safe access with a custom function (to avoid KeyErrors), modifying nested values, and recursively traversing a dictionary. The safe_get function is especially useful because it allows us to navigate a deep structure without worrying about missing keys. The traverse_dict function shows how to recursively explore all paths and values in a nested dictionary, which is helpful for debugging or visualization. Finally, we extract meaningful data by summarizing employee counts across departments."
    },
    {
      "title": "Dictionary Comprehensions and Transformations",
      "description": "Using dictionary comprehensions for data transformations.",
      "code": "# Sample data: Student test scores\ntest_scores = {\n    \"Alice\": [85, 90, 78, 92],\n    \"Bob\": [76, 88, 82, 81],\n    \"Charlie\": [95, 93, 89, 97],\n    \"David\": [65, 72, 68, 70],\n    \"Eva\": [91, 84, 88, 86]\n}\n\n# 1. Calculate average score for each student\naverage_scores = {name: sum(scores)/len(scores) for name, scores in test_scores.items()}\n\nprint(\"Average scores:\")\nfor name, avg in average_scores.items():\n    print(f\"{name}: {avg:.2f}\")\n\n# 2. Filter students with average score >= 85\nhigh_performers = {name: avg for name, avg in average_scores.items() if avg >= 85}\n\nprint(\"\\nHigh performers (average >= 85):\")\nfor name, avg in high_performers.items():\n    print(f\"{name}: {avg:.2f}\")\n\n# 3. Create a dictionary with letter grades based on average scores\ndef get_letter_grade(score):\n    if score >= 90:\n        return 'A'\n    elif score >= 80:\n        return 'B'\n    elif score >= 70:\n        return 'C'\n    elif score >= 60:\n        return 'D'\n    else:\n        return 'F'\n\nletter_grades = {name: get_letter_grade(avg) for name, avg in average_scores.items()}\n\nprint(\"\\nLetter grades:\")\nfor name, grade in letter_grades.items():\n    print(f\"{name}: {grade}\")\n\n# 4. Find the highest score for each student\nhighest_scores = {name: max(scores) for name, scores in test_scores.items()}\n\nprint(\"\\nHighest scores:\")\nfor name, score in highest_scores.items():\n    print(f\"{name}: {score}\")\n\n# 5. Count the number of A's, B's, etc. based on letter grades\ngrade_counts = {}\nfor grade in letter_grades.values():\n    if grade in grade_counts:\n        grade_counts[grade] += 1\n    else:\n        grade_counts[grade] = 1\n\nprint(\"\\nGrade distribution:\")\nfor grade, count in sorted(grade_counts.items()):\n    print(f\"{grade}: {count} student(s)\")\n\n# 6. Create a dictionary of students grouped by their letter grade\nstudents_by_grade = {}\nfor name, grade in letter_grades.items():\n    if grade not in students_by_grade:\n        students_by_grade[grade] = []\n    students_by_grade[grade].append(name)\n\nprint(\"\\nStudents grouped by grade:\")\nfor grade in sorted(students_by_grade.keys()):\n    print(f\"{grade}: {', '.join(students_by_grade[grade])}\")\n\n# 7. Create a dictionary with improvement metrics (difference between highest and first score)\nimprovement = {name: scores[-1] - scores[0] for name, scores in test_scores.items()}\n\nprint(\"\\nImprovement (last score - first score):\")\nfor name, change in sorted(improvement.items(), key=lambda x: x[1], reverse=True):\n    print(f\"{name}: {change:+d} points\")",
      "explanation": "This example demonstrates the power of dictionary comprehensions for transforming data. We start with a dictionary of student test scores and perform various transformations: calculating averages, filtering high performers, assigning letter grades, finding highest scores, counting grades, grouping students by grade, and calculating improvement metrics. Dictionary comprehensions offer a concise way to create new dictionaries from existing ones, especially when applying the same transformation to all items. We also show more complex transformations that can't be done with a single comprehension, like grade counting and grouping students by grade. The final example sorts the improvement dictionary by value, showing how to work with items() when ordering is important."
    }
  ],
  "practice_code": "# Practice with dictionaries\n\n# 1. Create a dictionary of favorite fruits and their colors\nfruits = {\n    \"apple\": \"red\",\n    \"banana\": \"yellow\",\n    \"grape\": \"purple\",\n    \"orange\": \"orange\",\n    \"kiwi\": \"green\"\n}\n\n# Print the dictionary\nprint(\"Fruit colors:\")\nfor fruit, color in fruits.items():\n    print(f\"{fruit}: {color}\")\n\n# 2. Access and modify values\nprint(f\"\\nThe color of an apple is {fruits['apple']}\")\n\n# Change the value for a key\nfruits[\"apple\"] = \"green\"  # Changed to green apple\nprint(f\"Now the apple is {fruits['apple']}\")\n\n# Add a new fruit\nfruits[\"strawberry\"] = \"red\"\n\n# 3. Check if a key exists\nif \"pear\" in fruits:\n    print(\"We have pears!\")\nelse:\n    print(\"We don't have pears!\")\n\n# 4. Get a value with default if key doesn't exist\npeach_color = fruits.get(\"peach\", \"not in stock\")\nprint(f\"Peach color: {peach_color}\")\n\n# 5. Dictionary methods\n# Get all keys\nfruit_names = list(fruits.keys())\nprint(f\"\\nAll fruits: {fruit_names}\")\n\n# Get all values\ncolors = list(fruits.values())\nprint(f\"All colors: {colors}\")\n\n# Remove an item\nremoved_fruit = fruits.pop(\"orange\")\nprint(f\"Removed {removed_fruit} orange\")\nprint(f\"Remaining fruits: {fruits}\")\n\n# 6. Dictionary comprehension\n# Create a dictionary of squared numbers\nsquares = {x: x**2 for x in range(1, 6)}\nprint(f\"\\nSquares: {squares}\")\n\n# Filter for even keys only\neven_squares = {k: v for k, v in squares.items() if k % 2 == 0}\nprint(f\"Even squares: {even_squares}\")\n\n# 7. Nested dictionaries\nstudents = {\n    \"Alice\": {\n        \"age\": 20,\n        \"grade\": \"A\",\n        \"courses\": [\"Math\", \"Physics\", \"Computer Science\"]\n    },\n    \"Bob\": {\n        \"age\": 22,\n        \"grade\": \"B\",\n        \"courses\": [\"Biology\", \"Chemistry\"]\n    }\n}\n\n# Access nested data\nprint(f\"\\nAlice's courses: {students['Alice']['courses']}\")\n\n# Add a new student\nstudents[\"Charlie\"] = {\n    \"age\": 21,\n    \"grade\": \"A-\",\n    \"courses\": [\"History\", \"English\", \"Art\"]\n}\n\n# 8. Try more dictionary operations below\n# Ideas: Create a frequency counter, group items, or transform data\n",
  "quiz": [
    {
      "question": "Which of the following is a valid way to create a dictionary in Python?",
      "options": [
        {"text": "dict(a=1, b=2, c=3)", "correct": true},
        {"text": "dict[a=1, b=2, c=3]", "correct": false},
        {"text": "dict((a, 1), (b, 2), (c, 3))", "correct": false},
        {"text": "{a:1, b:2, c:3}", "correct": false}
      ]
    },
    {
      "question": "What happens when you try to access a key that doesn't exist in a dictionary with dict[key]?",
      "options": [
        {"text": "It returns None", "correct": false},
        {"text": "It returns a default value", "correct": false},
        {"text": "It returns an empty value", "correct": false},
        {"text": "It raises a KeyError", "correct": true}
      ]
    },
    {
      "question": "Which method returns a default value if a key is not found in a dictionary?",
      "options": [
        {"text": "dict.find(key, default)", "correct": false},
        {"text": "dict.get(key, default)", "correct": true},
        {"text": "dict.default(key, value)", "correct": false},
        {"text": "dict.fetch(key, default)", "correct": false}
      ]
    },
    {
      "question": "What is the time complexity of accessing a value by key in a Python dictionary?",
      "options": [
        {"text": "O(1) - constant time", "correct": true},
        {"text": "O(log n) - logarithmic time", "correct": false},
        {"text": "O(n) - linear time", "correct": false},
        {"text": "O(nÂ²) - quadratic time", "correct": false}
      ]
    },
    {
      "question": "Which of the following can be used as a key in a Python dictionary?",
      "options": [
        {"text": "A list", "correct": false},
        {"text": "A dictionary", "correct": false},
        {"text": "A set", "correct": false},
        {"text": "A tuple of immutable values", "correct": true}
      ]
    }
  ],
  "problems": [
    {
      "id": "word_frequency",
      "title": "Word Frequency Counter",
      "description": "Write a function that takes a string of text and returns a dictionary where the keys are the words in the text and the values are the frequency of each word. Ignore case and punctuation.",
      "difficulty": "Medium",
      "starter_code": "def word_frequency(text):\n    # Your code here\n    pass\n\n# Test cases\ntext1 = \"The quick brown fox jumps over the lazy dog.\"\ntext2 = \"Apple apple Orange orange BANANA banana.\"\n\nprint(word_frequency(text1))\nprint(word_frequency(text2))",
      "tests": [
        {
          "description": "Test with simple text",
          "code": "result = word_frequency(\"The quick brown fox jumps over the lazy dog.\")\nassert result[\"the\"] == 2, \"Should count 'the' twice (case-insensitive)\"\nassert result[\"fox\"] == 1, \"Should count 'fox' once\"\nassert len(result) == 8, \"Should have 8 unique words\"",
          "expected_output": ""
        },
        {
          "description": "Test with repeated words",
          "code": "result = word_frequency(\"Apple apple Orange orange BANANA banana.\")\nassert result[\"apple\"] == 2, \"Should count 'apple' twice (case-insensitive)\"\nassert result[\"orange\"] == 2, \"Should count 'orange' twice (case-insensitive)\"\nassert result[\"banana\"] == 2, \"Should count 'banana' twice (case-insensitive)\"",
          "expected_output": ""
        },
        {
          "description": "Test with empty string",
          "code": "result = word_frequency(\"\")\nassert result == {}, \"Should return empty dictionary for empty string\"",
          "expected_output": ""
        },
        {
          "description": "Test with punctuation",
          "code": "result = word_frequency(\"Hello, world! Hello. Hello-World.\")\nassert result[\"hello\"] == 3, \"Should count 'hello' three times and ignore punctuation\"\nassert result[\"world\"] == 2, \"Should count 'world' twice and ignore punctuation\"",
          "expected_output": ""
        }
      ],
      "expected_output": "{'the': 2, 'quick': 1, 'brown': 1, 'fox': 1, 'jumps': 1, 'over': 1, 'lazy': 1, 'dog': 1}\n{'apple': 2, 'orange': 2, 'banana': 2}\n",
      "solution": "def word_frequency(text):\n    # Initialize an empty dictionary to store word counts\n    frequency = {}\n    \n    # Convert the text to lowercase\n    text = text.lower()\n    \n    # Replace punctuation with spaces\n    for char in '.,!?;:-()[]{}\"\\'':\n        text = text.replace(char, ' ')\n    \n    # Split the text into words\n    words = text.split()\n    \n    # Count the frequency of each word\n    for word in words:\n        if word in frequency:\n            frequency[word] += 1\n        else:\n            frequency[word] = 1\n    \n    return frequency\n\n# Alternative implementation using collections.Counter\n# from collections import Counter\n# import re\n# \n# def word_frequency(text):\n#     # Convert to lowercase and use regex to extract words\n#     words = re.findall(r'\\b\\w+\\b', text.lower())\n#     # Use Counter to count words\n#     return dict(Counter(words))\n\n# Test cases\ntext1 = \"The quick brown fox jumps over the lazy dog.\"\ntext2 = \"Apple apple Orange orange BANANA banana.\"\n\nprint(word_frequency(text1))\nprint(word_frequency(text2))"
    },
    {
      "id": "merge_dictionaries",
      "title": "Merge Dictionaries",
      "description": "Write a function that merges multiple dictionaries into a single dictionary. If the same key appears in more than one input dictionary, the value from the later dictionary should override the earlier value.",
      "difficulty": "Easy",
      "starter_code": "def merge_dicts(*dicts):\n    # Your code here\n    pass\n\n# Test cases\ndict1 = {\"a\": 1, \"b\": 2}\ndict2 = {\"b\": 3, \"c\": 4}\ndict3 = {\"d\": 5}\n\nprint(merge_dicts(dict1, dict2))  # Should return {\"a\": 1, \"b\": 3, \"c\": 4}\nprint(merge_dicts(dict1, dict2, dict3))  # Should return {\"a\": 1, \"b\": 3, \"c\": 4, \"d\": 5}\nprint(merge_dicts())  # Should return {}",
      "tests": [
        {
          "description": "Test with two dictionaries",
          "code": "result = merge_dicts({\"a\": 1, \"b\": 2}, {\"b\": 3, \"c\": 4})\nassert result == {\"a\": 1, \"b\": 3, \"c\": 4}, \"Should correctly merge two dictionaries\"",
          "expected_output": ""
        },
        {
          "description": "Test with three dictionaries",
          "code": "result = merge_dicts({\"a\": 1, \"b\": 2}, {\"b\": 3, \"c\": 4}, {\"d\": 5})\nassert result == {\"a\": 1, \"b\": 3, \"c\": 4, \"d\": 5}, \"Should correctly merge three dictionaries\"",
          "expected_output": ""
        },
        {
          "description": "Test with empty call",
          "code": "result = merge_dicts()\nassert result == {}, \"Should return empty dictionary when no arguments\"",
          "expected_output": ""
        },
        {
          "description": "Test with empty dictionaries",
          "code": "result = merge_dicts({}, {}, {})\nassert result == {}, \"Should return empty dictionary when all inputs are empty\"",
          "expected_output": ""
        },
        {
          "description": "Test value override",
          "code": "result = merge_dicts({\"x\": 1, \"y\": 2}, {\"y\": 3, \"z\": 4}, {\"y\": 5})\nassert result[\"y\"] == 5, \"Should use the value from the latest dictionary\"",
          "expected_output": ""
        }
      ],
      "expected_output": "{'a': 1, 'b': 3, 'c': 4}\n{'a': 1, 'b': 3, 'c': 4, 'd': 5}\n{}\n",
      "solution": "def merge_dicts(*dicts):\n    # Initialize an empty result dictionary\n    result = {}\n    \n    # Iterate through each dictionary and update the result\n    for d in dicts:\n        result.update(d)\n    \n    return result\n\n# Alternative implementation using dictionary unpacking (Python 3.5+)\n# def merge_dicts(*dicts):\n#     return {**d for d in dicts}\n\n# Another alternative\n# def merge_dicts(*dicts):\n#     result = {}\n#     for d in dicts:\n#         for key, value in d.items():\n#             result[key] = value\n#     return result\n\n# Test cases\ndict1 = {\"a\": 1, \"b\": 2}\ndict2 = {\"b\": 3, \"c\": 4}\ndict3 = {\"d\": 5}\n\nprint(merge_dicts(dict1, dict2))  # Should return {\"a\": 1, \"b\": 3, \"c\": 4}\nprint(merge_dicts(dict1, dict2, dict3))  # Should return {\"a\": 1, \"b\": 3, \"c\": 4, \"d\": 5}\nprint(merge_dicts())  # Should return {}"
    },
    {
      "id": "nested_dict_access",
      "title": "Nested Dictionary Access",
      "description": "Write a function called deep_get that safely accesses deeply nested dictionary values. The function should take a dictionary, a list of keys to traverse, and an optional default value to return if the path doesn't exist.",
      "difficulty": "Hard",
      "starter_code": "def deep_get(dictionary, keys, default=None):\n    # Your code here\n    pass\n\n# Test data\nperson = {\n    \"name\": \"John\",\n    \"age\": 30,\n    \"address\": {\n        \"street\": \"123 Main St\",\n        \"city\": \"Anytown\",\n        \"state\": \"CA\",\n        \"zipcode\": \"12345\"\n    },\n    \"contacts\": {\n        \"email\": \"john@example.com\",\n        \"phone\": {\n            \"home\": \"555-1234\",\n            \"work\": \"555-5678\"\n        }\n    }\n}\n\n# Test cases\nprint(deep_get(person, [\"name\"]))  # Should return \"John\"\nprint(deep_get(person, [\"address\", \"city\"]))  # Should return \"Anytown\"\nprint(deep_get(person, [\"contacts\", \"phone\", \"work\"]))  # Should return \"555-5678\"\nprint(deep_get(person, [\"contacts\", \"phone\", \"cell\"]))  # Should return None\nprint(deep_get(person, [\"contacts\", \"phone\", \"cell\"], \"Not Available\"))  # Should return \"Not Available\"",
      "tests": [
        {
          "description": "Test basic access",
          "code": "assert deep_get(person, [\"name\"]) == \"John\", \"Should access top-level key\"",
          "expected_output": ""
        },
        {
          "description": "Test nested access",
          "code": "assert deep_get(person, [\"address\", \"city\"]) == \"Anytown\", \"Should access nested key\"",
          "expected_output": ""
        },
        {
          "description": "Test deeper nested access",
          "code": "assert deep_get(person, [\"contacts\", \"phone\", \"work\"]) == \"555-5678\", \"Should access deeply nested key\"",
          "expected_output": ""
        },
        {
          "description": "Test missing key with default None",
          "code": "assert deep_get(person, [\"contacts\", \"phone\", \"cell\"]) is None, \"Should return None for missing key\"",
          "expected_output": ""
        },
        {
          "description": "Test missing key with custom default",
          "code": "assert deep_get(person, [\"contacts\", \"phone\", \"cell\"], \"Not Available\") == \"Not Available\", \"Should return custom default for missing key\"",
          "expected_output": ""
        },
        {
          "description": "Test with empty keys list",
          "code": "assert deep_get(person, []) == person, \"Should return the entire dictionary when keys list is empty\"",
          "expected_output": ""
        },
        {
          "description": "Test with invalid dictionary",
          "code": "assert deep_get(None, [\"any\", \"keys\"]) is None, \"Should handle non-dictionary input\"",
          "expected_output": ""
        }
      ],
      "expected_output": "John\nAnytown\n555-5678\nNone\nNot Available\n",
      "solution": "def deep_get(dictionary, keys, default=None):\n    # Check if dictionary is valid\n    if dictionary is None or not isinstance(dictionary, dict):\n        return default\n    \n    # If no keys are provided, return the whole dictionary\n    if not keys:\n        return dictionary\n    \n    # Start with the initial dictionary\n    current = dictionary\n    \n    # Traverse the keys\n    for key in keys:\n        # If current is not a dictionary or key doesn't exist, return default\n        if not isinstance(current, dict) or key not in current:\n            return default\n        \n        # Move to the next level\n        current = current[key]\n    \n    return current\n\n# Alternative implementation using a recursive approach\n# def deep_get(dictionary, keys, default=None):\n#     if dictionary is None or not isinstance(dictionary, dict):\n#         return default\n#     \n#     if not keys:\n#         return dictionary\n#     \n#     if keys[0] not in dictionary:\n#         return default\n#     \n#     if len(keys) == 1:\n#         return dictionary[keys[0]]\n#     \n#     return deep_get(dictionary[keys[0]], keys[1:], default)\n\n# Test data\nperson = {\n    \"name\": \"John\",\n    \"age\": 30,\n    \"address\": {\n        \"street\": \"123 Main St\",\n        \"city\": \"Anytown\",\n        \"state\": \"CA\",\n        \"zipcode\": \"12345\"\n    },\n    \"contacts\": {\n        \"email\": \"john@example.com\",\n        \"phone\": {\n            \"home\": \"555-1234\",\n            \"work\": \"555-5678\"\n        }\n    }\n}\n\n# Test cases\nprint(deep_get(person, [\"name\"]))  # Should return \"John\"\nprint(deep_get(person, [\"address\", \"city\"]))  # Should return \"Anytown\"\nprint(deep_get(person, [\"contacts\", \"phone\", \"work\"]))  # Should return \"555-5678\"\nprint(deep_get(person, [\"contacts\", \"phone\", \"cell\"]))  # Should return None\nprint(deep_get(person, [\"contacts\", \"phone\", \"cell\"], \"Not Available\"))  # Should return \"Not Available\""
    }
  ],
  "next_lesson": "modules"
}
